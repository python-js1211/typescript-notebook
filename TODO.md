1. Use tsconfig from users workspace folder, closest to the ipynb file.
2. Generate/update sourcemaps when we process code
    * for top level awaits
    * replacing const with var (note: we change the body again here)
    probably should process top level awaits then replace globals with vars.
3. Interactive widow will be better
4. Better want to view image tensors
5. Variable viewer? or tensor viewer or easy image viewer (from tensors)?
6. Changing cwd permanently
7. Cell magics (to change CWD, send variable from node to browser)?
8. Use shell path from vscode settings
Ignore language (doesn't matter whether its shell or powershell).
At the end of the day the shell is setup by the user.
9. For simple (most common) shell commands like `echo`, `rm`, `pwd`, `cwd`, we don't need a real terminal, just run as a spawn (faster). As long as ther'es nothing streaming.
10. Clean up webpack & old stuff from package.json (commands, settigs, etc) & webpack, etc
11. Use a webview instead of a Panel, as the state is not preserved & its not tied to a particular notebook.
    This way we can open the new webview on the side.
12. Use ESBuild for extension (excluding `node-pty`, that's better bundled & shipped in node_modules folder, this way the bundle will pick it)
13. Fix prettier, etc

# Shipping
* Icon
* Svg file
* Main file
* Readme
* Roadmap, use github issues with milestones (v1, v2, etc)
* CI

# Tests
* tests
* tests
* tests
* tests
* tests
# Bugs
* Unused imports in cells are never generated by TSC
    * Solution take the following, inspect the AST `import * as xyz, { Cls } from 'abc'`
    * Generate code such as `console.log(<GUID>, xyz, Cls )`
    * Then TSC will generate the code for the imports, and we can use acorn to delete the `console.log` we added & subsequently update source maps...

* We cannot append multiple Mime types to an existing output. E.g. can't put two stdout & 3 dtderr & html into an Output.
We're supposed to have unique output
We're supposed to have unique mime types in each Output.
* When we get messages from renderer, we don't know what notebook it belongs to.
NotebookEditor doesn't have any public members.
* Class, Function hoisting
    * We can add code such as `this.<className> = className`; this way we let JS hoist functions, classes
    * & ensure we map the genrated souce maps accordingly.
    * This will work

E.g.
```typecript
await sleep();
cosnt instance = new ClassName();

class ClassName {

}
```
Then running the following code will fail (because ClassName is private in lexical scoping):
```
cosnt instance = new ClassName();
```
Solution is to convert the typescript/js code to the following (`this.ClassName = ClassName;`):
Eureka moment
```typecript
this.ClassName = ClassName;
await sleep();
cosnt instance = new ClassName();

class ClassName {

}
```


* Source map issues (variable hoisting)
    * Have an option to never hoist (default)
    * Have option to hoist
    * Check telemetry to see how many run such code (with variable hoisting enabled)
* Magics must be excluded from being executed as JS code (else parser will fall over & hang)

# Telemetry
* See whether we need variable hoisting
(easy, parse the code & check if we have classes/functions)
* Variable hoisting
    * At worst, we notify users that this will not work when debugging (yuck)
    * Or we open a dummy cell & start debugging that code (yuck)

