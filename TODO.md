1. Use tsconfig from users workspace folder, closest to the ipynb file.
2. Generate/update sourcemaps when we process code
    * for top level awaits
    * replacing const with var (note: we change the body again here)
    probably should process top level awaits then replace globals with vars.
3. Interactive widow will be better
4. Better want to view image tensors
5. Variable viewer? or tensor viewer or easy image viewer (from tensors)?
6. Changing cwd permanently
7. Cell magics (to change CWD, send variable from node to browser)?
8. Use shell path from vscode settings
Ignore language (doesn't matter whether its shell or powershell).
At the end of the day the shell is setup by the user.
9. For simple (most common) shell commands like `echo`, `rm`, `pwd`, `cwd`, we don't need a real terminal, just run as a spawn (faster). As long as ther'es nothing streaming.
10. Clean up webpack & old stuff from package.json (commands, settigs, etc) & webpack, etc
11. Use a webview instead of a Panel, as the state is not preserved & its not tied to a particular notebook.
    This way we can open the new webview on the side.
12. Use ESBuild for extension (excluding `node-pty`, that's better bundled & shipped in node_modules folder, this way the bundle will pick it)
13. Fix prettier, etc
14. We know when we have hacked to ensure functions & classes are available in other cells.
E.g. if we have a cell such as
```typescript
z = await Promise.resolve(2134);
class OneThat3 {
    public doIt(){
        console.log('Done3');
        return 3;
    }
}
const x = new OneThat3()
```
If we run this as is in another cell, OneThat3 will not be available in subsequent cells.
Similarly if `OneThat3` is a funciton it will not be available in subsequent cells.
This is because we wrap them with `(async () => {<cell body>})()`.
In such cases we have a hacky solution.
But if the user instead has code such as the following, they'll get `OneThat3` not defined
```typescript
const x = new OneThat3()
z = await Promise.resolve(2134);
class OneThat3 {
    public doIt(){
        console.log('Done3');
        return 3;
    }
}
```

We can definitely detect such errors & we know we caused it, hence we can display a message for this & suggest the user
turn off a flag, but source maps will not work when debugging.



# Shipping
* Icon
* Svg file
* Main file
* Readme
* Roadmap, use github issues with milestones (v1, v2, etc)
* CI

# Tests
* tests
* tests
* tests
* tests
* tests
# Bugs
* When debugging, we do'nt see variables
* Should wrap every cell in an IIFE, so we can see variables as variables.
* Display message if we fail to start node process (currently just hangs)
* Unused imports in cells are never generated by TSC
    * Solution take the following, inspect the AST `import * as xyz, { Cls } from 'abc'`
    * Generate code such as `console.log(<GUID>, xyz, Cls )`
    * Then TSC will generate the code for the imports, and we can use acorn to delete the `console.log` we added & subsequently update source maps...

* We cannot append multiple Mime types to an existing output. E.g. can't put two stdout & 3 dtderr & html into an Output.
We're supposed to have unique output
We're supposed to have unique mime types in each Output.
* When we get messages from renderer, we don't know what notebook it belongs to.
NotebookEditor doesn't have any public members.
* Class, Function hoisting
    * We can add code such as `this.<className> = className`; this way we let JS hoist functions, classes
    * & ensure we map the genrated souce maps accordingly.
    * This will work

E.g.
```typecript
await sleep();
cosnt instance = new ClassName();

class ClassName {

}
```
Then running the following code will fail (because ClassName is private in lexical scoping):
```
cosnt instance = new ClassName();
```
Solution is to convert the typescript/js code to the following (`this.ClassName = ClassName;`):
Eureka moment
```typecript
this.ClassName = ClassName;
await sleep();
cosnt instance = new ClassName();

class ClassName {

}
```


* Source map issues (variable hoisting)
    * Have an option to never hoist (default)
    * Have option to hoist
    * Check telemetry to see how many run such code (with variable hoisting enabled)
* Magics must be excluded from being executed as JS code (else parser will fall over & hang)

# Telemetry
* See whether we need variable hoisting
(easy, parse the code & check if we have classes/functions)
* Variable hoisting
    * At worst, we notify users that this will not work when debugging (yuck)
    * Or we open a dummy cell & start debugging that code (yuck)



# Known issues
* Hoisting is always an issue (after all its just hacky, we're changing user code)
* Printing value of last expression vs `console.log`
See below
```typescript
    var s = await Promise.resolve(1);
    function bye(){
        console.log("Bye");
    }
    bye();
    s
```
When you run this, the value `1` will be displayed first and then we'll see `Bye`.
This is because we get output from repl before we get output from stdout of the process.
** SOLUTION **
* After we get the result from the repl, we can send a `console.log(<GUID>)`, this will
tell the UI that we have some output that will be coming.
Next we sent out result via websockets. We should not display the output we got from the socket
until we've received the `<GUID>` from `process.stdout`, once we wait, we know any `console.log` the
user sent would have been received & printed in the right order.
Thus if we look at the above example, the output would be in the right order as follows:
```
Bye
1
```

